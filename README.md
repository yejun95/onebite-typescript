# 인프런 한입 크기로 잘라 먹는 타입스크립트 강의 정리
## ✔️ section1 directory
- `npm i @types/node` : node.js의 내장 기능들을 위한 타입 정보를 제공

- `npm i typescript -g` : typesciprt 컴파일러
  - `tsc --init` : 타입스크립트 컴파일러 옵션 -> tsconfig.json 생성됨
<br>

- tsconfig.json 설정
<br>
<hr>
<br>

## ✔️ section2 directory
### 원시 타입
- 하나의 값만 저장하는 타입
  - 타입 어노테이션 : ex) `let a: number = 1;` 이라고 하였을 때, :(콜론)뒤에 붙는 타입을 타입 주석 또는 타입 어노테이션이라고 한다.

- number

- string

- boolean

- null

- undefined

- 리터럴 타입
<br>
<br>

### 배열과 튜플
- 배열 타입

- 튜플 타입 : 길이와 타입이 고정된 배열
<br>
<br>

### 객체
- Optional

- readonly
<br>
<br>

### 타입 별칭과 인덱스 시그니처
- 타입 별칭 : 객체 선언 시 변수 객체를 통해 할당하는 것

- 인덱스 시그니처 : 동일한 형식의 `key : value`로 값이 계속 추가 된다면 사용하기 용이함
<br>
<br>

### enum
- enum 타입 등록을 통해 열거된 변수를 프로퍼티나 변수에 할당 가능
<br>
<br>

### any, unknown
- any : 특정 변수의 타입을 우리가 확실히 모를 때 사용
  - 다른 타입에 다 넣을 수 있다.
  - 그러나 마지막 타입이 불일치하면 런타임시에 에러가 남
  - 고로 최대한 사용하지 말아야한다.
<br>

- unknown : any와 마찬가지로 어떤 타입이든 넣을 수 있음
  - 그러나 any와 다르게 다른 타입에 넣기 불가능 => 컴파일 시점에 에러를 잡을 수 있음
  - 만약 타입을 모른다면 any말고 unknown을 쓰도록 하자.
<br>
<br>

### void, Never
- void : 공허 -> 아무것도 없다. -> 아무것도 없는 타입
  - 함수에 리턴문이 없을 경우 사용 -> ex) console.log만 찍는 경우
  - undefined를 제외 하고는 모든 타입 매핑이 불가능
  - `tsconfig`에서 `strictNullChecks = false` 인 경우 null 값 매핑 가능
<br>

- never : 존재하지 않는 -> 불가능한 타입
  - `while(true)` 처럼 무한루프일 경우에 사용
  - 또는 함수가 `throw new Error` 처럼 예외 처리를 리턴하는 경우 사용
  - void와 다르게 모든 타입에 대해서 매핑이 불가능하다.
<br>
<hr>
<br>

## ✔️ section3 directory
### 타입 계층도

![타입계층도](https://github.com/user-attachments/assets/aaf04645-ac95-47f5-8177-fd173849c6a2)
<br>

- 부모는 자식을 품을 수 있다. (업 캐스팅)

- 자식은 부모를 품을 수 없다. (다운 캐스팅)

- 즉, 더 상위에 있는 타입은 아래 타입을 품을 수 있다.

- 그러나 `never` 타입의 경우 어떠한 것도 캐스팅 불가능

- `any` 타입은 모든 타입의 슈퍼타입이나 서브타입으로도 가능 -> 물론 `never` 타입 제외
<br>
<br>

### 객체간 호환성
- 객체간 캐스팅이 가능

- 그러나 프로퍼티가 적은 객체를 프로퍼티가 많은 객체 쪽으로 넣을 수 없다.
  - 타입스크립트는 프로퍼티를 기준으로 하는 구조적 타입 시스템을 채택
  - 즉, 프로퍼티가 적은 쪽이 슈퍼 타입이 되는 것
<br>

- 초과 프로퍼티 검사
  - 프로퍼티가 많은 객체를 적은 객체쪽으로 넣는 것은 가능
<br>
<br>

### 대수 타입
- 여러개의 타입을 합성해서 새롭게 만들어내는 타입

- 합집합 : `|`

- 교집합 : `&`
<br>
<br>

### 타입 추론
- 타입스크립트는 변수의 초기값을 통해 자동으로 타입을 추론한다.

- string, number, object 등 변수의 초기값만 설정되었다면 타입을 선언하지 않아도 알아서 매핑 되는 것이다.

- const로 선언된 변수는 값이 어차피 변하지 않기 때문에 리터럴 타입이라고 생각하면 된다.

- 초기값 생략 시 any 타입으로 매핑되며, 이 때 초기화 되는 값에 따라 타입이 변경된다. -> any 타입의 진화
<br>
<br>

### 타입 단언
- type assertion

- 타입에 맞는 값을 초기화하지 않아도 as 문법으로 매핑 가능

- 타입 단언의 규칙
  - 값 as 단언 <- 단언식
  - A as B
  - A가 B의 슈퍼타입이거나
  - A가 B의 서브타입이어야 함
<br>

- 객체를 `as const`로 타입 단언 시 리터럴 타입으로 추론되기 때문에 프로퍼티의 값을 변경하거나 추가할 수 없다.

- Non Null 단언
  - 객체 프로퍼티에 `?` 를 붙이면 값이 없을 수도 있다 표시하는 것 -> undefined를 예상함
  - `!`를 붙여서 Null이나 Undefined이 무조건 아니라고 단언
<br>
<br>

### 타입 좁히기
- 조건문을 이용해 넓은타입에서 좁은타입으로
  - `typeof`
  - `instanceof`
  - `"{property}" in 매개변수`
<br>
<br>

### 서로소 유니온 타입
- 교집합이 없는 타입들로만 만든 유니온 타입을 말함

- 타입 별칭에 특정 프로퍼티를 문자열로 지정함으로써 교집합이 없는 타입을 만듬
  - 같은 이름의 프로퍼티가 다른 타입 별칭에 존재하여도 문자열을 직접 입력했기 때문에 서로소임
<br>
<hr>
<br>

## ✔️ section4 directory
### 함수타입
- 함수 타입은 어떤 타입의 매개변수를 갖고, 어떤 타입의 리턴을 내는지를 야기한다.

- 화살표 함수도 타입 선언 가능
<br>
<br>

### 함수타입 표현식과 호출 시그니처
- 함수 타입 표현식을 통한 타입 별칭을 선언 -> 함수에 타입을 붙여서 사용 가능

- 함수 타입 표현식과 동일 하지만 매개 변수에 넣는 형식으로 타입 별칭으로 만들어 함수에 붙여 사용 가능
<br>
<br>

### 함수 타입의 호환성
- 반환 값의 타입 호환

- 매개변수의 타입 호환
  - 매개변수가 같을 때 : 다운캐스팅만 가능
  - 매개변수가 다를 때 : 매개변수가 많은 쪽이 적은 쪽을 받을 수 있음
<br>
<br>

### 함수 오버로딩
- 자바의 오버로딩과 같은 개념으로 하나의 함수에 매개변수를 다르게 주어 사용 가능

- 리턴을 void로 주고 매개변수를 다르게 부여한다.
<br>
<br>

### 사용자 정의 타입 가드
- 타입 별칭으로 타입가드 생성 가능
<br>
<hr>
<br>

## ✔️ section5 directory
### 인터페이스
- `type`이 아닌 `interface` 라는 명칭을 사용한다.

- `type`과 동일하게 타입 선언을 할 수 있지만 `=` 부등호 없이 사용한다.
<br>
<br>

### 인터페이스 확장
- 인터페이스의 경우 `extends`를 통해 타입 확장이 가능하다.

- 자바의 상속과 같이 상속하는 타입이 부모고 상속받는 쪽이 자식이 되어 부모의 타입을 자식이 사용할 수 있게 된다.
  - 상속 선언만 하면 해당 타입을 자식에서 선언하지 않아도 자동으로 매핑됨
<br>

- 상속은 무한대로 가능 `interface a extends b, c, d, f`

- 상속을 받은 후 부모의 타입을 자식에서 재정의를 할 수 있지만 부모 타입에 맞는 서브타입이어야만 가능
  - ex) 부모 타입이 string -> 자식에서 문자 리터럴 타입으로 정의 가능
  - 부모 타입이 문자 리터럴 타입이면 자식에서 string으로 재정의 불가능
<br>

- 타입 별칭의 경우 상속을 받을 수는 없지만 인터페이스에 상속자(부모)로 사용할 수는 있다.
<br>
<br>

### 인터페이스 선언 합침
- 타입의 경우 동일 변수 사용이 불가능하지만 인터페이스의 경우 동일한 이름으로 선언된 경우 자동으로 타입 변수가 합쳐진다.

- 주로 고정되어 있는 라이브러리 타입을 재정의할 때 사용하면 좋다.
